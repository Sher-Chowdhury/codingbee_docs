# Local Volumes

All the pods that we've demoed so far stored all their data internally inside the containers. This data is deleted if/when the container is terminated. However what if you want to keep the data? In that case you need to store teh data outside the container, but also give the container access to the data as well. That's possible by using Kubernetes Volumes. Kubernetes volumes comes in various types and we'll start with looking at one of the simplest type, emptyDir. 







The pods you build may need storage space for storing application data. For this you can allocate some of your worker node's disk space. There are a lot of other more sophisticated [storage options](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes) available, which we'll cover later. However from this list, the only solutions that ends up using the working node's own diskpace are:


1. [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) - Non Persistant local storage. If container inside pod dies and gets rebuilt, then the data persists. But if whole pod dies, then the data in the volume gets wiped out. You can think of these volumes as living inside a pod.
2. [hostPath](https://kubernetes.io/docs/concepts/storage/volumes/#hostpath) - Persistant local storage


## hostPath volumes

hostPath volumes let's you share a worker node's directory with a container inside a pod.

Once you have applied this, you should see the following folder now exists (you can also created some test content in this folder):

```bash
$ minikube ssh
$ ls -l /tmp | grep webcontent
drwxr-xr-x 2 root root   40 Mar  7 19:24 webcontent
$ echo 'hello hostpath content' > /tmp/webcontent/index.html
```

Then back on our macbook we apply and test:

```bash
$ curl http://192.168.99.100:31000
hello hostpath content
```

You can also share the same hostpath directory to multiple containers/pods on the same worker node. One powerful usecase for this is that you can store all logs centrally using hostPaths, and then use DeamonSet to deploy a filebeat pod, which ships all the hostPaths content to an elk server. But need to figure out how to append pod unique names to log file's names to avoid unintended overwrites of log files. 

hostPath is rarely used in practice because:

- if worker node dies, then all the data is lost with it. 
- if pod dies and gets rebuilt, then there's a good chance it will get rebuilt on a different worker node, in which case it loses access to the data storage, until it gets rebuilt on the correct worker node. However a way round this problem is to build the pods using stateful states controller objects. 



## EmptyDir

In your pod definitions you can specify a particular command to run. Here's an example:

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: pod-httpd
  labels:
    component: apache_webserver
spec:
  volumes:
    - name: webcontent    #Â here we specify the name of the volume
      emptyDir: {}        # the '{}' is yaml syntax to represent an empty dictionary
  containers:
    - name: cntr-httpd
      image: httpd
      volumeMounts:
        - name: webcontent
          mountPath: /usr/local/apache2/htdocs
      ports:
        - containerPort: 80
    - name: cntr-centos
      image: centos
      volumeMounts:
        - name: webcontent
          mountPath: /tmp/reports
      command: ["/bin/bash", "-c"]
      args:
        - while true ; do
            echo "this content is being generated by the centos container" >> /tmp/reports/index.html ;
            date >> /tmp/reports/index.html ;
            sleep 5 ;
          done
        # this args gets parsed as a single line, so have to end relevant line with a ';'
```

In this example, we will actually build a 2-container pod. These 2 containers are sharing a storage volume (which we called webcontent). This volume is of the type 'emptyDir', which in kubernetes world, is ephemeral storage (it get's deleted when the pod is deleted). cntr-centos is running a custom command, which is effectively updating the index.html file that's being used by the other container. Since it's now a 2-container pod, you have to wait a few seconds longer for the pod to become ready:

```bash
$ kubectl apply -f configs/command-example/pod-object-definition.yml
pod "pod-httpd" created

$ kubectl get pods
NAME        READY     STATUS              RESTARTS   AGE
pod-httpd   0/2       ContainerCreating   0          3s
$ kubectl get pods
NAME        READY     STATUS              RESTARTS   AGE
pod-httpd   0/2       ContainerCreating   0          8s
$ kubectl get pods
NAME        READY     STATUS    RESTARTS   AGE
pod-httpd   2/2       Running   0          29s


$ curl http://192.168.99.100:31000
this content is being generated by the centos container
Fri Feb 22 11:24:49 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:24:54 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:24:59 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:25:04 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:25:09 UTC 2019

```

One thing to note, is that the command you specify needs to be a long running command. Otherwise  the container will keep shutting down inside the pod, and kubernetes will then think the container has failed will keep restarting that container again.

A possible use case for using emptyDir type of volume is where you have a primary container whose logs you want to keep track of in which case, you would have a secondary log forwarding container, e.g. a filebeat container, and you share the //var/log contents from the primary container with the filebeat container.