# emptyDir Volumes

When a container is terminated, then the data inside the container (if any) also gets deleted. For example if a mysql database is running inside a container, then the chances are that you don't want to lose that data when the mysql container dies for any reason. That's where Kubernetes volumes comes into the picture. Volumes let's you store your data outside of your containers, your containers can then mount these volumes in the same way you mount block devices on a Linux machine. There are a lot of different types of Kubernetes volumes, one of the most basic type is the [emptyDir volume](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir). 


emptyDir volumes exists outside a container but inside the pod. This setup offers two features that we can make use of:

- If the container dies, then kubernetes will launch a new container inside the pod, and that container will reconnect to the volume and pick up where the previous container left off
- emptyDir volumes are only mountable by containers in the same pod. 



One possible use case for using emptyDir is when you have a 2 container pod, where the main container app outputs logs, and the sidecar container is a log-forwarder that will forward your log to a log aggregator such as ELK server. In that scenario, you can have a emptyDir volume mounted on to the directory where your main app writes logs to. Then on the sidecar container, you mount the same volume so that it can read the logs and forward them to the elk server.

However we don't have an ELK server to demonstrate this, so in our demo we'll create a 2-container pod, the main container is a httpd container, and the sidecar container is a centos container. The centos container will create the index.html file which the httpd container will display via an emptyDir volume:

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: pod-httpd
  labels:
    component: httpd_pods
spec:
  volumes:
    - name: webcontent    # here we specify the name of the volume
      emptyDir: {}        # the '{}' is yaml syntax to represent an empty dictionary
  containers:
    - name: cntr-httpd
      image: httpd
      volumeMounts:                        # Here we mount the volume
        - name: webcontent
          mountPath: /usr/local/apache2/htdocs
      ports:
        - containerPort: 80
    - name: cntr-centos
      image: centos
      volumeMounts:                        # Here we mount the volume
        - name: webcontent
          mountPath: /tmp/reports       # this folder is created if it doesn't already exist.
      command: ["/bin/bash", "-c"]
      args:
        - |
          while true ; do
            echo "this content is being generated by the centos container, $(hostname)" >> /tmp/reports/index.html
            date >> /tmp/reports/index.html
            sleep 5
          done
```












The pods you build may need storage space for storing application data. For this you can allocate some of your worker node's disk space. There are a lot of other more sophisticated [storage options](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes) available, which we'll cover later. However from this list, the only solutions that ends up using the working node's own diskpace are:


1. [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) - Non Persistant local storage. If container inside pod dies and gets rebuilt, then the data persists. But if whole pod dies, then the data in the volume gets wiped out. You can think of these volumes as living inside a pod.
2. [hostPath](https://kubernetes.io/docs/concepts/storage/volumes/#hostpath) - Persistant local storage


## hostPath volumes

hostPath volumes let's you share a worker node's directory with a container inside a pod.

Once you have applied this, you should see the following folder now exists (you can also created some test content in this folder):

```bash
$ minikube ssh
$ ls -l /tmp | grep webcontent
drwxr-xr-x 2 root root   40 Mar  7 19:24 webcontent
$ echo 'hello hostpath content' > /tmp/webcontent/index.html
```

Then back on our macbook we apply and test:

```bash
$ curl http://192.168.99.100:31000
hello hostpath content
```

You can also share the same hostpath directory to multiple containers/pods on the same worker node. One powerful usecase for this is that you can store all logs centrally using hostPaths, and then use DeamonSet to deploy a filebeat pod, which ships all the hostPaths content to an elk server. But need to figure out how to append pod unique names to log file's names to avoid unintended overwrites of log files. 

hostPath is rarely used in practice because:

- if worker node dies, then all the data is lost with it. 
- if pod dies and gets rebuilt, then there's a good chance it will get rebuilt on a different worker node, in which case it loses access to the data storage, until it gets rebuilt on the correct worker node. However a way round this problem is to build the pods using stateful states controller objects. 



## EmptyDir

In your pod definitions you can specify a particular command to run. Here's an example:

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: pod-httpd
  labels:
    component: apache_webserver
spec:
  volumes:
    - name: webcontent    # here we specify the name of the volume
      emptyDir: {}        # the '{}' is yaml syntax to represent an empty dictionary
  containers:
    - name: cntr-httpd
      image: httpd
      volumeMounts:
        - name: webcontent
          mountPath: /usr/local/apache2/htdocs
      ports:
        - containerPort: 80
    - name: cntr-centos
      image: centos
      volumeMounts:
        - name: webcontent
          mountPath: /tmp/reports
      command: ["/bin/bash", "-c"]
      args:
        - while true ; do
            echo "this content is being generated by the centos container" >> /tmp/reports/index.html ;
            date >> /tmp/reports/index.html ;
            sleep 5 ;
          done
        # this args gets parsed as a single line, so have to end relevant line with a ';'
```

In this example, we will actually build a 2-container pod. These 2 containers are sharing a storage volume (which we called webcontent). This volume is of the type 'emptyDir', which in kubernetes world, is ephemeral storage (it get's deleted when the pod is deleted). cntr-centos is running a custom command, which is effectively updating the index.html file that's being used by the other container. Since it's now a 2-container pod, you have to wait a few seconds longer for the pod to become ready:

```bash
$ kubectl apply -f configs/command-example/pod-object-definition.yml
pod "pod-httpd" created

$ kubectl get pods
NAME        READY     STATUS              RESTARTS   AGE
pod-httpd   0/2       ContainerCreating   0          3s
$ kubectl get pods
NAME        READY     STATUS              RESTARTS   AGE
pod-httpd   0/2       ContainerCreating   0          8s
$ kubectl get pods
NAME        READY     STATUS    RESTARTS   AGE
pod-httpd   2/2       Running   0          29s


$ curl http://192.168.99.100:31000
this content is being generated by the centos container
Fri Feb 22 11:24:49 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:24:54 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:24:59 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:25:04 UTC 2019
this content is being generated by the centos container
Fri Feb 22 11:25:09 UTC 2019

```

One thing to note, is that the command you specify needs to be a long running command. Otherwise  the container will keep shutting down inside the pod, and kubernetes will then think the container has failed will keep restarting that container again.

A possible use case for using emptyDir type of volume is where you have a primary container whose logs you want to keep track of in which case, you would have a secondary log forwarding container, e.g. a filebeat container, and you share the //var/log contents from the primary container with the filebeat container.